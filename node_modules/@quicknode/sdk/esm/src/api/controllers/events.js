import { __decorate, __metadata } from 'tslib';
import { contractEventsValidator } from '../types/events/getByContract.js';
import { collectionEventsValidator } from '../types/nfts/getCollectionEvents.js';
import { nftEventsValidator } from '../types/nfts/getNFTEvents.js';
import { allEventsValidator } from '../types/events/getAll.js';
import { CodegenEthereumMainnetEventsByContractDocument, CodegenPolygonMainnetEventsByContractDocument, CodegenEthereumSepoliaEventsByContractDocument, CodegenEthMainnetEventsByCollectionDocument, CodegenPolygonMainnetEventsByCollectionDocument, CodegenEthSepoliaEventsByCollectionDocument, CodegenEthereumMainnetEventsByNftDocument, CodegenPolygonMainnetEventsByNftDocument, CodegenEthSepoliaEventsByNftDocument, CodegenEthereumMainnetEventsGetAllDocument, CodegenPolygonMainnetEventsGetAllDocument, CodegenEthereumSepoliaEventsGetAllDocument } from '../graphql/generatedTypes.js';
import { formatQueryResult } from '../utils/postQueryFormatter.js';
import { emptyPageInfo } from '../utils/helpers.js';
import { DEFAULT_CHAIN } from '../utils/constants.js';
import { ValidateInput } from '../../lib/validation/ValidateInput.js';

class EventsController {
    constructor(client, defaultChain = DEFAULT_CHAIN) {
        this.client = client;
        this.defaultChain = defaultChain;
    }
    async getByContract(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthereumMainnetEventsByContractDocument,
            polygon: CodegenPolygonMainnetEventsByContractDocument,
            ethereumSepolia: CodegenEthereumSepoliaEventsByContractDocument,
        };
        const { data: { [userChain]: { contract }, }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        if (!contract?.tokenEvents?.length) {
            return {
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(contract, 'tokenEvents', 'tokenEventsPageInfo');
        return formattedResult;
    }
    async getByNFTCollection(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetEventsByCollectionDocument,
            polygon: CodegenPolygonMainnetEventsByCollectionDocument,
            ethereumSepolia: CodegenEthSepoliaEventsByCollectionDocument,
        };
        const { data: { [userChain]: { collection }, }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        if (!collection?.tokenEvents?.length)
            return { results: [], pageInfo: emptyPageInfo };
        function removeKeyFields(results) {
            const { address, ...newResults } = results;
            return newResults;
        }
        const formattedResult = formatQueryResult(collection, 'tokenEvents', 'tokenEventsPageInfo', null, removeKeyFields);
        return formattedResult;
    }
    async getByNFT(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthereumMainnetEventsByNftDocument,
            polygon: CodegenPolygonMainnetEventsByNftDocument,
            ethereumSepolia: CodegenEthSepoliaEventsByNftDocument,
        };
        const { data: { [userChain]: { nft }, }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        if (!nft?.tokenEvents?.length)
            return { results: [], pageInfo: emptyPageInfo };
        function removeKeyFields(results) {
            const { contractAddress, tokenId, ...newResults } = results;
            return newResults;
        }
        const formattedResult = formatQueryResult(nft, 'tokenEvents', 'tokenEventsPageInfo', null, removeKeyFields);
        return formattedResult;
    }
    async getAll(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthereumMainnetEventsGetAllDocument,
            polygon: CodegenPolygonMainnetEventsGetAllDocument,
            ethereumSepolia: CodegenEthereumSepoliaEventsGetAllDocument,
        };
        const { data: { [userChain]: tokenEvents }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        const formattedResult = formatQueryResult(tokenEvents, 'tokenEvents', 'tokenEventsPageInfo');
        return formattedResult;
    }
}
__decorate([
    ValidateInput(contractEventsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], EventsController.prototype, "getByContract", null);
__decorate([
    ValidateInput(collectionEventsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], EventsController.prototype, "getByNFTCollection", null);
__decorate([
    ValidateInput(nftEventsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], EventsController.prototype, "getByNFT", null);
__decorate([
    ValidateInput(allEventsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], EventsController.prototype, "getAll", null);

export { EventsController };
