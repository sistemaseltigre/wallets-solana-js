import { __decorate, __metadata } from 'tslib';
import { walletByAddressValidator } from '../types/nfts/getByWalletAddress.js';
import { nftDetailsValidator } from '../types/nfts/getNFTDetails.js';
import { nftCollectionDetailsValidator } from '../types/nfts/getCollectionDetails.js';
import { nftTrendingCollectionsValidator } from '../types/nfts/getTrendingCollections.js';
import { nftsByContractAddressValidator } from '../types/nfts/getByContractAddress.js';
import { verifyOwnershipValidator } from '../types/nfts/verifyOwnershipByAddress.js';
import { CodegenEthMainnetWalletNFTsByEnsDocument, CodegenPolygonMainnetWalletNFTsByEnsDocument, CodegenEthSepoliaWalletNFTsByEnsDocument, CodegenEthMainnetWalletNFTsByAddressDocument, CodegenPolygonMainnetWalletNFTsByAddressDocument, CodegenEthSepoliaWalletNFTsByAddressDocument, CodegenEthMainnetTrendingCollectionsDocument, CodegenPolygonMainnetTrendingCollectionsDocument, CodegenEthSepoliaTrendingCollectionsDocument, CodegenEthMainnetWalletNFTsByContractAddressDocument, CodegenPolygonMainnetNFTsByContractAddressDocument, CodegenEthSepoliaWalletNFTsByContractAddressDocument, CodegenEthMainnetNFTDetailsDocument, CodegenPolygonMainnetNFTDetailsDocument, CodegenEthSepoliaNFTDetailsDocument, CodegenEthMainnetNftCollectionDetailsDocument, CodegenPolygonMainnetNftCollectionDetailsDocument, CodegenEthSepoliaNftCollectionDetailsDocument, CodegenEthMainnetVerifyOwnershipByAddressDocument, CodegenPolygonMainnetVerifyOwnershipByAddressDocument, CodegenEthSepoliaVerifyOwnershipByAddressDocument, CodegenEthMainnetVerifyOwnershipByENSDocument, CodegenPolygonMainnetVerifyOwnershipByENSDocument, CodegenEthSepoliaVerifyOwnershipByENSDocument } from '../graphql/generatedTypes.js';
import { formatQueryResult } from '../utils/postQueryFormatter.js';
import { emptyPageInfo } from '../utils/helpers.js';
import { DEFAULT_CHAIN } from '../utils/constants.js';
import { isValidENSAddress } from '../utils/isValidENSAddress.js';
import { ValidateInput } from '../../lib/validation/ValidateInput.js';

class NftsController {
    constructor(client, defaultChain = DEFAULT_CHAIN) {
        this.client = client;
        this.defaultChain = defaultChain;
    }
    async getByWallet(variables) {
        const { address, ...allVariables } = variables;
        if (isValidENSAddress(address)) {
            return this.getByWalletENS({
                ensName: address,
                ...allVariables,
            });
        }
        return this.getByWalletAddress({
            address,
            ...allVariables,
        });
    }
    async getByWalletENS(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetWalletNFTsByEnsDocument,
            polygon: CodegenPolygonMainnetWalletNFTsByEnsDocument,
            ethereumSepolia: CodegenEthSepoliaWalletNFTsByEnsDocument,
        };
        const { data: { [userChain]: { walletByENS }, }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        if (!walletByENS?.walletNFTs?.length) {
            // Address can still be valid ENS name, but not have any NFTs
            const address = walletByENS?.address || '';
            const ensName = walletByENS?.ensName || '';
            return {
                address: address,
                ensName: ensName,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(walletByENS, 'walletNFTs', 'walletNFTsPageInfo', 'nft');
        return formattedResult;
    }
    async getByWalletAddress(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetWalletNFTsByAddressDocument,
            polygon: CodegenPolygonMainnetWalletNFTsByAddressDocument,
            ethereumSepolia: CodegenEthSepoliaWalletNFTsByAddressDocument,
        };
        const { data: { [userChain]: { walletByAddress }, }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        if (!walletByAddress?.walletNFTs?.length) {
            const address = walletByAddress?.address || '';
            const ensName = walletByAddress?.ensName || '';
            return {
                address: address,
                ensName: ensName,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(walletByAddress, 'walletNFTs', 'walletNFTsPageInfo', 'nft');
        return formattedResult;
    }
    async getTrendingCollections(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetTrendingCollectionsDocument,
            polygon: CodegenPolygonMainnetTrendingCollectionsDocument,
            ethereumSepolia: CodegenEthSepoliaTrendingCollectionsDocument,
        };
        const { data: { [userChain]: trendingCollections }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        const formattedResult = formatQueryResult(trendingCollections, 'trendingCollections', 'trendingCollectionsPageInfo', 'collection');
        return formattedResult;
    }
    async getByContractAddress(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetWalletNFTsByContractAddressDocument,
            polygon: CodegenPolygonMainnetNFTsByContractAddressDocument,
            ethereumSepolia: CodegenEthSepoliaWalletNFTsByContractAddressDocument,
        };
        const { data: { [userChain]: { collection }, }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        if (!collection?.nfts?.length) {
            return {
                standard: null,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const setErcStandard = (results) => {
            const standardMap = {
                ERC1155Collection: 'ERC1155',
                ERC721Collection: 'ERC721',
            };
            // Remove address too since it was only used as a key field
            const { __typename, address, ...newResults } = results;
            return {
                ...newResults,
                standard: standardMap[results['__typename']] || null,
            };
        };
        const formattedResult = formatQueryResult(collection, 'nfts', 'nftsPageInfo', null, setErcStandard);
        return formattedResult;
    }
    async getNFTDetails(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetNFTDetailsDocument,
            polygon: CodegenPolygonMainnetNFTDetailsDocument,
            ethereumSepolia: CodegenEthSepoliaNFTDetailsDocument,
        };
        const { data: { [userChain]: { nft }, }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        if (nft)
            return { nft };
        return { nft: null };
    }
    async getCollectionDetails(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetNftCollectionDetailsDocument,
            polygon: CodegenPolygonMainnetNftCollectionDetailsDocument,
            ethereumSepolia: CodegenEthSepoliaNftCollectionDetailsDocument,
        };
        const { data: { [userChain]: { collection }, }, } = await this.client.query({
            query: query[userChain],
            variables: queryVariables,
        });
        if (collection)
            return { collection };
        return { collection: null };
    }
    async verifyOwnership(variables) {
        const { address, ...allVariables } = variables;
        if (isValidENSAddress(address)) {
            return this.verifyOwnershipByENS({
                ensName: address,
                ...allVariables,
            });
        }
        return this.verifyOwnershipByAddress({
            address,
            ...allVariables,
        });
    }
    async verifyOwnershipByAddress(variables) {
        const { chain, address, nfts } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetVerifyOwnershipByAddressDocument,
            polygon: CodegenPolygonMainnetVerifyOwnershipByAddressDocument,
            ethereumSepolia: CodegenEthSepoliaVerifyOwnershipByAddressDocument,
        };
        const { data: { [userChain]: { walletByAddress }, }, } = await this.client.query({
            query: query[userChain],
            variables: { address, filter: { contractTokens: nfts } },
        });
        return !!walletByAddress?.walletNFTs?.length;
    }
    async verifyOwnershipByENS(variables) {
        const { chain, ensName, nfts } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetVerifyOwnershipByENSDocument,
            polygon: CodegenPolygonMainnetVerifyOwnershipByENSDocument,
            ethereumSepolia: CodegenEthSepoliaVerifyOwnershipByENSDocument,
        };
        const { data: { [userChain]: { walletByENS }, }, } = await this.client.query({
            query: query[userChain],
            variables: { ensName, filter: { contractTokens: nfts } },
        });
        return !!walletByENS?.walletNFTs?.length;
    }
}
__decorate([
    ValidateInput(walletByAddressValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getByWallet", null);
__decorate([
    ValidateInput(nftTrendingCollectionsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getTrendingCollections", null);
__decorate([
    ValidateInput(nftsByContractAddressValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getByContractAddress", null);
__decorate([
    ValidateInput(nftDetailsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getNFTDetails", null);
__decorate([
    ValidateInput(nftCollectionDetailsValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "getCollectionDetails", null);
__decorate([
    ValidateInput(verifyOwnershipValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NftsController.prototype, "verifyOwnership", null);

export { NftsController };
