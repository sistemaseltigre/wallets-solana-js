import { __decorate, __metadata } from 'tslib';
import { DEFAULT_CHAIN } from '../utils/constants.js';
import { transactionsBySearchValidator } from '../types/transactions/getBySearch.js';
import { transactionsByHashValidator } from '../types/transactions/getByHash.js';
import { CodegenEthMainnetTransactionsByWalletAddressDocument, CodegenPolygonMainnetTransactionsByWalletAddressDocument, CodegenEthSepoliaTransactionsByWalletAddressDocument, CodegenEthMainnetTransactionsByWalletENSDocument, CodegenPolygonMainnetTransactionsByWalletENSDocument, CodegenEthSepoliaTransactionsByWalletENSDocument, CodegenEthMainnetTransactionsBySearchDocument, CodegenPolygonMainnetTransactionsBySearchDocument, CodegenEthSepoliaTransactionsBySearchDocument, CodegenEthMainnetTransactionsByHashDocument, CodegenPolygonMainnetTransactionsByHashDocument, CodegenEthSepoliaTransactionsByHashDocument } from '../graphql/generatedTypes.js';
import { emptyPageInfo } from '../utils/helpers.js';
import { formatQueryResult } from '../utils/postQueryFormatter.js';
import { isValidENSAddress } from '../utils/isValidENSAddress.js';
import { ValidateInput } from '../../lib/validation/ValidateInput.js';
import { balancesByWalletAddressValidator } from '../types/tokens/getBalancesByWalletAddress.js';

class TransactionsController {
    constructor(client, defaultChain = DEFAULT_CHAIN) {
        this.client = client;
        this.defaultChain = defaultChain;
    }
    async getByWallet(variables) {
        const { address, ...allVariables } = variables;
        let queryResult;
        if (isValidENSAddress(address)) {
            queryResult = await this.getByWalletENS({
                ensName: address,
                ...allVariables,
            });
        }
        else {
            queryResult = await this.getByWalletAddress({
                address,
                ...allVariables,
            });
        }
        if (!queryResult?.transactions?.length) {
            // Address can still be valid address, but not have any transactions
            const address = queryResult?.address || '';
            const ensName = queryResult?.ensName || '';
            return {
                address: address,
                ensName: ensName,
                results: [],
                pageInfo: emptyPageInfo,
            };
        }
        const formattedResult = formatQueryResult(queryResult, 'transactions', 'transactionsPageInfo');
        return formattedResult;
    }
    async getByWalletAddress(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetTransactionsByWalletAddressDocument,
            polygon: CodegenPolygonMainnetTransactionsByWalletAddressDocument,
            ethereumSepolia: CodegenEthSepoliaTransactionsByWalletAddressDocument,
        };
        const { data: { [userChain]: { walletByAddress }, }, } = await this.client.query({
            variables: queryVariables,
            query: query[userChain],
        });
        return walletByAddress;
    }
    async getByWalletENS(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetTransactionsByWalletENSDocument,
            polygon: CodegenPolygonMainnetTransactionsByWalletENSDocument,
            ethereumSepolia: CodegenEthSepoliaTransactionsByWalletENSDocument,
        };
        const { data: { [userChain]: { walletByENS }, }, } = await this.client.query({
            variables: queryVariables,
            query: query[userChain],
        });
        return walletByENS;
    }
    async getAll(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetTransactionsBySearchDocument,
            polygon: CodegenPolygonMainnetTransactionsBySearchDocument,
            ethereumSepolia: CodegenEthSepoliaTransactionsBySearchDocument,
        };
        const { data: { [userChain]: transactions }, } = await this.client.query({
            variables: queryVariables,
            query: query[userChain],
        });
        const formattedResult = formatQueryResult(transactions, 'transactions', 'transactionsPageInfo');
        return formattedResult;
    }
    async getByHash(variables) {
        const { chain, ...queryVariables } = variables;
        const userChain = chain || this.defaultChain;
        const query = {
            ethereum: CodegenEthMainnetTransactionsByHashDocument,
            polygon: CodegenPolygonMainnetTransactionsByHashDocument,
            ethereumSepolia: CodegenEthSepoliaTransactionsByHashDocument,
        };
        const { data: { [userChain]: transaction }, } = await this.client.query({
            variables: queryVariables,
            query: query[userChain],
        });
        if (transaction?.transaction)
            return transaction;
        return { transaction: null };
    }
}
__decorate([
    ValidateInput(balancesByWalletAddressValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getByWallet", null);
__decorate([
    ValidateInput(transactionsBySearchValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getAll", null);
__decorate([
    ValidateInput(transactionsByHashValidator),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TransactionsController.prototype, "getByHash", null);

export { TransactionsController };
