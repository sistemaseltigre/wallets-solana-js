import { z } from 'zod';
import { isContractStandard, isMarketplace, isTokenTransferType } from './codegenDerivedValidators.js';
import { supportedChains } from '../../api/types/chains.js';
import { isValidENSAddress } from '../../api/utils/isValidENSAddress.js';

const isEvmAddress = z
    .string()
    .length(42) // Using built-in function for better error messages
    .startsWith('0x') // Using built-in function for better error messages
    .regex(/^0x[a-fA-F0-9]{40}$/, 'Not a valid address');
const isENSAddress = z.string().refine((val) => isValidENSAddress(val));
const isEvmTransactionHash = z
    .string()
    .length(66) // Using built-in function for better error messages
    .startsWith('0x') // Using built-in function for better error messages
    .regex(/^0x[a-fA-F0-9]{64}$/, 'Not a valid transaction hash');
const supportedChainInput = z
    .object({
    chain: z.enum(supportedChains).nullish(),
})
    .strict();
function fullFilters(baseType) {
    return z
        .object({
        eq: baseType.nullish(),
        gt: baseType.nullish(),
        gte: baseType.nullish(),
        in: z.array(baseType).nullish(),
        lt: baseType.nullish(),
        lte: baseType.nullish(),
        notIn: z.array(baseType).nullish(),
    })
        .strict();
}
function limitedFilters(baseType) {
    return z
        .object({
        eq: baseType.nullish(),
        in: z.array(baseType).nullish(),
        notIn: z.array(baseType).nullish(),
    })
        .strict();
}
const tokenEventFilters = z
    .object({
    blockNumber: fullFilters(z.number().positive()).nullish(),
    contractAddress: limitedFilters(isEvmAddress).nullish(),
    contractStandard: limitedFilters(isContractStandard).nullish(),
    fromAddress: limitedFilters(isEvmAddress).nullish(),
    marketplace: limitedFilters(isMarketplace).nullish(),
    timestamp: fullFilters(z.string().datetime({ offset: true })).nullish(),
    toAddress: limitedFilters(isEvmAddress).nullish(),
    transactionHash: limitedFilters(isEvmTransactionHash).nullish(),
    type: limitedFilters(isTokenTransferType).nullish(),
    walletAddress: limitedFilters(isEvmAddress).nullish(),
})
    .strict();
const transactionFilters = z
    .object({
    blockNumber: fullFilters(z.number().positive()).nullish(),
    fromAddress: isEvmAddress.nullish(),
    timestamp: fullFilters(z.string().datetime({ offset: true })).nullish(),
    toAddress: isEvmAddress.nullish(),
})
    .strict();
const gasPriceFilters = z
    .object({
    blockNumber: fullFilters(z.number().positive()).nullish(),
})
    .strict();
const paginationParams = z
    .object({
    before: z.string().nullish(),
    after: z.string().nullish(),
    first: z.number().positive().nullish(),
})
    .strict();
const baseEventsInput = z
    .object({
    filter: tokenEventFilters.nullish(),
})
    .merge(paginationParams)
    .strict();
const baseTransactionsInput = z
    .object({
    filter: transactionFilters.optional(),
})
    .merge(paginationParams)
    .strict();
const contractTokensFilter = z
    .array(z
    .object({
    contractAddress: isEvmAddress,
    tokenId: z.string().optional(),
})
    .strict())
    .nonempty();
const rpcPaginationParams = z
    .object({
    perPage: z.number().positive().nullish(),
    page: z.number().positive().nullish(),
})
    .strict();

export { baseEventsInput, baseTransactionsInput, contractTokensFilter, gasPriceFilters, isENSAddress, isEvmAddress, isEvmTransactionHash, paginationParams, rpcPaginationParams, supportedChainInput, tokenEventFilters, transactionFilters };
