import { QNInputValidationError } from '../errors/QNInputValidationError.js';

function formatErrors(baseError) {
    const errorMessages = [];
    baseError.errors.forEach((error) => {
        errorMessages.push(`${error.path.length > 0 ? error.path + ': ' : ''}${error.message}`);
    });
    return errorMessages.length > 0
        ? new QNInputValidationError({
            messages: errorMessages,
            zodError: baseError,
        })
        : null;
}
// Decorator for runtime validation to handle input that is unknown at compile time
function ValidateInput(schema) {
    return function (target, propertyName, descriptor) {
        const method = descriptor.value;
        if (!method)
            return;
        descriptor.value = async function (...args) {
            const [input] = args;
            const validation = schema.safeParse(input);
            if (!validation.success) {
                const formattedErrors = formatErrors(validation.error);
                if (formattedErrors) {
                    throw formattedErrors;
                }
            }
            return method.apply(this, args);
        };
    };
}

export { ValidateInput, formatErrors };
